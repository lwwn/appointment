一个vue webApp  大概由nodejs环境  npm包管理     vue-cli (脚手架,主要简化配置 基于webpack(依赖nodejs 环境) )

21/2/23
  env 是依赖什么（环境）?  是什么 ?
  
  vue-cli  是一个模式和环境配置文件。方便在不同的开发模式切换。 
  
  参考： env 对应的是 vue-cli 中的（https://cli.vuejs.org/zh/guide/mode-and-env.html#%E6%A8%A1%E5%BC%8F），模式和环境变量。
     
  模式指的是应用的模式 具体有开发模式(developer)  Test模式     生产模式(production)  每种模式都有与之对应的环境变量文件 env(developer) env.test (test) env.prod (production)。 
  cli 运行时会加载环境变量文件,读取里面配置的环境变量。
  
  有一点需要注意，只有 NODE_ENV  BASE_URL  VUE_APP_  定义的变量会打包到静态代码中。
  
  访问环境变量 
    列如： 环境变量中定义了以下字段
       NODE_ENV = development
       VUE_APP_TITLE = 'APP'
       
       在js 文件中这样访问  process.env.VUE_APP_TITLE
       
  环境文件的优先级  
     env环境文件每次都会被加载， 但特定模式准备的环境文件会比env环境具有更高的优先级 （注意：修改了环境文件后，需要重新启动应用）
     
     
21/2/24  
   vue-cli 项目中 遇见require 方法,在其他非cli项目中，使用require 需要引入require.js 文件。但cli项目中一般都没有引入require . 那这个require 是基于那个环境呢?
   
   这儿的require 是基于webpack的依赖管理。
   参考：https://webpack.docschina.org/guides/dependency-management/#requirecontext
   
   在查询require 的时候大概了解了一下require其他信息。比如为什么会诞生require 。
      在2009年 Ryan Dahl 创建了nodejs 项目 ，把js 用于服务器端。 但服务器端一定需要模块化编程，node核心就是模块化编程。 正是在这种思想下，催生了两种模块化规范, 一是commonJS 和 AMD commonJs,
      也诞生以这种规范的工具包。如
      require.js  和sea.js(cmd规范的追谁者)
      参考：commonjs规范文档  https://javascript.ruanyifeng.com/nodejs/module.html 

20/12/10
 vue 项目中使用webcan 完成摄像头拍照打卡功能。 支持IE 
 1.首先下载webcan资源文件，并放在public 文件夹中webcam.swf 也放在这个文件夹。
 2.具体使用页面
  html  <div id="my_camera" class="my_camera"></div>  webcam 的引用 
         <el-button style="margin-top: 20px" type="primary" @click="take_snapshot">拍摄图片</el-button>

 js :  在mounted 中完成配置
       mounted() {
    Webcam.set({
      width: 320,
      height: 240,
      image_format: 'jpeg',
      jpeg_quality: 90,
    });
    Webcam.attach('#my_camera');
   },
   
   拍照方法 
    take_snapshot: function () {
      // take snapshot and get image data
      let _this = this;

      Webcam.snap(function (data_uri) {
        // console.log(data_uri, 'data_uri');
        let theBob = _this.dataURLtoFile(data_uri, 'file', 'jpg');
        // console.log(theBob, '-------------');

        // let formData = new FormData();
        //data 为二进制的blob图片骗数据,//fileName 文件名
        // formData.append('files',theBob.file, theBob.name);
        // console.log(formData,'formData');
        let params = {
          base64: data_uri,
        };
        imgUpload(params).then(res => {
          if(res.code == 200){
          _this.ruleForm.signInOutImg = res.data.url
            msg.success('成功')
             
          }
        });

     
      });
    },
    
    21/3/1 
     今天写vue，父组件向子组件传参？还是报了直接改变属性这个错。 头痛，这些这么基础的东西。还不记住。
       Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop's value. Prop being mutated: "test"
       避免直接改变属性，因为每当父组件重新渲染时，该值将被覆盖。相反，使用基于属性值的数据或计算属性。道具变异：“测试”。
       vue 中要保持数据单向流动。
       后面又看了一遍，prop 篇 主要 讲了
         1.命名的问题，组件的名称使用驼峰命名，但是在浏览器中，浏览器对标签大小写不敏感。
         2.prop介绍如何传入一个，数字，字符串，布尔值，对象，数组。 prop可以对传入的数据进行类型检查。 还可以自定义类型。prop 是单向向下进行数据流动，请不要在子级改变prop 数据。
           如果需要依赖这个prop，可以换成计算属性。 还有一点需要注意（prop 传递数组，对象的时候，其实传递的是一个引用，所以在子组件改变了这个变量，相应的宰所有的地方，都进行了相应的改变。）
         3.非prop 属性的处理。
           一般情况下，非prop属性会被加在组件的根元树上。 但也可以设置禁用非prop属性，只需要在组件上设置inheritAttrs: false 属性即可。
            还可以配合实列 $attrs 属性。进行操作，$attrs 包含了传递给一个组件的 attribute 名和 attribute 值。（还有一个注意点，style class 不会受此影响）

      
  
